// THIS FILE WAS AUTOGENERATED - ANY EDITS TO THIS WILL BE LOST WHEN IT IS REGENERATED
// GENERATED USING KEYSPACE clio
// AT 2016-12-02 13:03:43.903363511 +0000 GMT USING cqlc VERSION 0.10.5
// AGAINST HOST ID a67bb232-ea11-47e5-bcca-6c0187a5fc95 (SERVER VERSION 3.9)
// CLIENT NEGOTIATED CQL VERSION 3.0.0 (SERVER SUPPORTS UP TO 3.4.2)

package cassandra

import (
	"github.com/relops/cqlc/cqlc"

	"log"

	"time"

	"github.com/gocql/gocql"
)

const (
	CQLC_VERSION = "0.10.5"
)

type LogsBuildIdColumn struct {
}

func (b *LogsBuildIdColumn) ColumnName() string {
	return "build_id"
}

func (b *LogsBuildIdColumn) To(value *gocql.UUID) cqlc.ColumnBinding {
	return cqlc.ColumnBinding{Column: b, Value: value}
}

func (b *LogsBuildIdColumn) Eq(value gocql.UUID) cqlc.Condition {
	column := &LogsBuildIdColumn{}
	binding := cqlc.ColumnBinding{Column: column, Value: value}
	return cqlc.Condition{Binding: binding, Predicate: cqlc.EqPredicate}
}

func (b *LogsBuildIdColumn) PartitionBy() cqlc.Column {
	return b
}

func (b *LogsBuildIdColumn) In(value ...gocql.UUID) cqlc.Condition {
	column := &LogsBuildIdColumn{}
	binding := cqlc.ColumnBinding{Column: column, Value: value}
	return cqlc.Condition{Binding: binding, Predicate: cqlc.InPredicate}
}

type LogsContainerIdColumn struct {
	desc bool
}

func (b *LogsContainerIdColumn) ColumnName() string {
	return "container_id"
}

func (b *LogsContainerIdColumn) To(value *string) cqlc.ColumnBinding {
	return cqlc.ColumnBinding{Column: b, Value: value}
}

func (b *LogsContainerIdColumn) ClusterWith() string {
	return b.ColumnName()
}

func (b *LogsContainerIdColumn) Desc() cqlc.ClusteredColumn {
	return &LogsContainerIdColumn{desc: true}
}

func (b *LogsContainerIdColumn) IsDescending() bool {
	return b.desc
}

func (b *LogsContainerIdColumn) Eq(value string) cqlc.Condition {
	column := &LogsContainerIdColumn{}
	binding := cqlc.ColumnBinding{Column: column, Value: value}
	return cqlc.Condition{Binding: binding, Predicate: cqlc.EqPredicate}
}

func (b *LogsContainerIdColumn) In(value ...string) cqlc.Condition {
	column := &LogsContainerIdColumn{}
	binding := cqlc.ColumnBinding{Column: column, Value: value}
	return cqlc.Condition{Binding: binding, Predicate: cqlc.InPredicate}
}

func (b *LogsContainerIdColumn) Gt(value string) cqlc.Condition {
	column := &LogsContainerIdColumn{}
	binding := cqlc.ColumnBinding{Column: column, Value: value}
	return cqlc.Condition{Binding: binding, Predicate: cqlc.GtPredicate}
}
func (b *LogsContainerIdColumn) Ge(value string) cqlc.Condition {
	column := &LogsContainerIdColumn{}
	binding := cqlc.ColumnBinding{Column: column, Value: value}
	return cqlc.Condition{Binding: binding, Predicate: cqlc.GePredicate}
}
func (b *LogsContainerIdColumn) Lt(value string) cqlc.Condition {
	column := &LogsContainerIdColumn{}
	binding := cqlc.ColumnBinding{Column: column, Value: value}
	return cqlc.Condition{Binding: binding, Predicate: cqlc.LtPredicate}
}
func (b *LogsContainerIdColumn) Le(value string) cqlc.Condition {
	column := &LogsContainerIdColumn{}
	binding := cqlc.ColumnBinding{Column: column, Value: value}
	return cqlc.Condition{Binding: binding, Predicate: cqlc.LePredicate}
}

type LogsContainerNameColumn struct {
}

func (b *LogsContainerNameColumn) ColumnName() string {
	return "container_name"
}

func (b *LogsContainerNameColumn) To(value *string) cqlc.ColumnBinding {
	return cqlc.ColumnBinding{Column: b, Value: value}
}

type LogsCreatedAtColumn struct {
	desc bool
}

func (b *LogsCreatedAtColumn) ColumnName() string {
	return "created_at"
}

func (b *LogsCreatedAtColumn) To(value *time.Time) cqlc.ColumnBinding {
	return cqlc.ColumnBinding{Column: b, Value: value}
}

func (b *LogsCreatedAtColumn) ClusterWith() string {
	return b.ColumnName()
}

func (b *LogsCreatedAtColumn) Desc() cqlc.ClusteredColumn {
	return &LogsCreatedAtColumn{desc: true}
}

func (b *LogsCreatedAtColumn) IsDescending() bool {
	return b.desc
}

func (b *LogsCreatedAtColumn) Eq(value time.Time) cqlc.Condition {
	column := &LogsCreatedAtColumn{}
	binding := cqlc.ColumnBinding{Column: column, Value: value}
	return cqlc.Condition{Binding: binding, Predicate: cqlc.EqPredicate}
}

func (b *LogsCreatedAtColumn) Gt(value time.Time) cqlc.Condition {
	column := &LogsCreatedAtColumn{}
	binding := cqlc.ColumnBinding{Column: column, Value: value}
	return cqlc.Condition{Binding: binding, Predicate: cqlc.GtPredicate}
}
func (b *LogsCreatedAtColumn) Ge(value time.Time) cqlc.Condition {
	column := &LogsCreatedAtColumn{}
	binding := cqlc.ColumnBinding{Column: column, Value: value}
	return cqlc.Condition{Binding: binding, Predicate: cqlc.GePredicate}
}
func (b *LogsCreatedAtColumn) Lt(value time.Time) cqlc.Condition {
	column := &LogsCreatedAtColumn{}
	binding := cqlc.ColumnBinding{Column: column, Value: value}
	return cqlc.Condition{Binding: binding, Predicate: cqlc.LtPredicate}
}
func (b *LogsCreatedAtColumn) Le(value time.Time) cqlc.Condition {
	column := &LogsCreatedAtColumn{}
	binding := cqlc.ColumnBinding{Column: column, Value: value}
	return cqlc.Condition{Binding: binding, Predicate: cqlc.LePredicate}
}

type LogsPayloadColumn struct {
}

func (b *LogsPayloadColumn) ColumnName() string {
	return "payload"
}

func (b *LogsPayloadColumn) To(value *string) cqlc.ColumnBinding {
	return cqlc.ColumnBinding{Column: b, Value: value}
}

type Logs struct {
	BuildId gocql.UUID

	ContainerId string

	ContainerName string

	CreatedAt time.Time

	Payload string
}

func (s *Logs) BuildIdValue() gocql.UUID {
	return s.BuildId
}

func (s *Logs) ContainerIdValue() string {
	return s.ContainerId
}

func (s *Logs) ContainerNameValue() string {
	return s.ContainerName
}

func (s *Logs) CreatedAtValue() time.Time {
	return s.CreatedAt
}

func (s *Logs) PayloadValue() string {
	return s.Payload
}

type LogsDef struct {
	BUILD_ID cqlc.LastPartitionedUUIDColumn

	CONTAINER_ID cqlc.LastClusteredStringColumn

	CONTAINER_NAME cqlc.StringColumn

	CREATED_AT cqlc.ClusteredTimestampColumn

	PAYLOAD cqlc.StringColumn
}

func BindLogs(iter *gocql.Iter) ([]Logs, error) {
	array := make([]Logs, 0)
	err := MapLogs(iter, func(t Logs) (bool, error) {
		array = append(array, t)
		return true, nil
	})
	return array, err
}

func MapLogs(iter *gocql.Iter, callback func(t Logs) (bool, error)) error {
	columns := iter.Columns()
	row := make([]interface{}, len(columns))

	for {
		t := Logs{}

		for i := 0; i < len(columns); i++ {
			switch columns[i].Name {

			case "build_id":
				row[i] = &t.BuildId

			case "container_id":
				row[i] = &t.ContainerId

			case "container_name":
				row[i] = &t.ContainerName

			case "created_at":
				row[i] = &t.CreatedAt

			case "payload":
				row[i] = &t.Payload

			default:
				log.Fatal("unhandled column: ", columns[i].Name)
			}
		}
		if !iter.Scan(row...) {
			break
		}

		readNext, err := callback(t)
		if err != nil {
			return err
		}
		if !readNext {
			return nil
		}
	}

	return nil
}

func (s *LogsDef) SupportsUpsert() bool {
	return true
}

func (s *LogsDef) TableName() string {
	return "logs"
}

func (s *LogsDef) Keyspace() string {
	return "clio"
}

func (s *LogsDef) Bind(v Logs) cqlc.TableBinding {
	cols := []cqlc.ColumnBinding{

		cqlc.ColumnBinding{Column: &LogsBuildIdColumn{}, Value: v.BuildId},

		cqlc.ColumnBinding{Column: &LogsContainerIdColumn{}, Value: v.ContainerId},

		cqlc.ColumnBinding{Column: &LogsContainerNameColumn{}, Value: v.ContainerName},

		cqlc.ColumnBinding{Column: &LogsCreatedAtColumn{}, Value: v.CreatedAt},

		cqlc.ColumnBinding{Column: &LogsPayloadColumn{}, Value: v.Payload},
	}
	return cqlc.TableBinding{Table: &LogsDef{}, Columns: cols}
}

func (s *LogsDef) To(v *Logs) cqlc.TableBinding {
	cols := []cqlc.ColumnBinding{

		cqlc.ColumnBinding{Column: &LogsBuildIdColumn{}, Value: &v.BuildId},

		cqlc.ColumnBinding{Column: &LogsContainerIdColumn{}, Value: &v.ContainerId},

		cqlc.ColumnBinding{Column: &LogsContainerNameColumn{}, Value: &v.ContainerName},

		cqlc.ColumnBinding{Column: &LogsCreatedAtColumn{}, Value: &v.CreatedAt},

		cqlc.ColumnBinding{Column: &LogsPayloadColumn{}, Value: &v.Payload},
	}
	return cqlc.TableBinding{Table: &LogsDef{}, Columns: cols}
}

func (s *LogsDef) ColumnDefinitions() []cqlc.Column {
	return []cqlc.Column{

		&LogsBuildIdColumn{},

		&LogsContainerIdColumn{},

		&LogsContainerNameColumn{},

		&LogsCreatedAtColumn{},

		&LogsPayloadColumn{},
	}
}

func LogsTableDef() *LogsDef {
	return &LogsDef{

		BUILD_ID: &LogsBuildIdColumn{},

		CONTAINER_ID: &LogsContainerIdColumn{},

		CONTAINER_NAME: &LogsContainerNameColumn{},

		CREATED_AT: &LogsCreatedAtColumn{},

		PAYLOAD: &LogsPayloadColumn{},
	}
}

func (s *LogsDef) BuildIdColumn() cqlc.LastPartitionedUUIDColumn {
	return &LogsBuildIdColumn{}
}

func (s *LogsDef) ContainerIdColumn() cqlc.LastClusteredStringColumn {
	return &LogsContainerIdColumn{}
}

func (s *LogsDef) ContainerNameColumn() cqlc.StringColumn {
	return &LogsContainerNameColumn{}
}

func (s *LogsDef) CreatedAtColumn() cqlc.ClusteredTimestampColumn {
	return &LogsCreatedAtColumn{}
}

func (s *LogsDef) PayloadColumn() cqlc.StringColumn {
	return &LogsPayloadColumn{}
}

type SchemaMigrationsVersionColumn struct {
}

func (b *SchemaMigrationsVersionColumn) ColumnName() string {
	return "version"
}

func (b *SchemaMigrationsVersionColumn) To(value *int64) cqlc.ColumnBinding {
	return cqlc.ColumnBinding{Column: b, Value: value}
}

func (b *SchemaMigrationsVersionColumn) Eq(value int64) cqlc.Condition {
	column := &SchemaMigrationsVersionColumn{}
	binding := cqlc.ColumnBinding{Column: column, Value: value}
	return cqlc.Condition{Binding: binding, Predicate: cqlc.EqPredicate}
}

func (b *SchemaMigrationsVersionColumn) PartitionBy() cqlc.Column {
	return b
}

func (b *SchemaMigrationsVersionColumn) In(value ...int64) cqlc.Condition {
	column := &SchemaMigrationsVersionColumn{}
	binding := cqlc.ColumnBinding{Column: column, Value: value}
	return cqlc.Condition{Binding: binding, Predicate: cqlc.InPredicate}
}

type SchemaMigrations struct {
	Version int64
}

func (s *SchemaMigrations) VersionValue() int64 {
	return s.Version
}

type SchemaMigrationsDef struct {
	VERSION cqlc.LastPartitionedInt64Column
}

func BindSchemaMigrations(iter *gocql.Iter) ([]SchemaMigrations, error) {
	array := make([]SchemaMigrations, 0)
	err := MapSchemaMigrations(iter, func(t SchemaMigrations) (bool, error) {
		array = append(array, t)
		return true, nil
	})
	return array, err
}

func MapSchemaMigrations(iter *gocql.Iter, callback func(t SchemaMigrations) (bool, error)) error {
	columns := iter.Columns()
	row := make([]interface{}, len(columns))

	for {
		t := SchemaMigrations{}

		for i := 0; i < len(columns); i++ {
			switch columns[i].Name {

			case "version":
				row[i] = &t.Version

			default:
				log.Fatal("unhandled column: ", columns[i].Name)
			}
		}
		if !iter.Scan(row...) {
			break
		}

		readNext, err := callback(t)
		if err != nil {
			return err
		}
		if !readNext {
			return nil
		}
	}

	return nil
}

func (s *SchemaMigrationsDef) SupportsUpsert() bool {
	return true
}

func (s *SchemaMigrationsDef) TableName() string {
	return "schema_migrations"
}

func (s *SchemaMigrationsDef) Keyspace() string {
	return "clio"
}

func (s *SchemaMigrationsDef) Bind(v SchemaMigrations) cqlc.TableBinding {
	cols := []cqlc.ColumnBinding{

		cqlc.ColumnBinding{Column: &SchemaMigrationsVersionColumn{}, Value: v.Version},
	}
	return cqlc.TableBinding{Table: &SchemaMigrationsDef{}, Columns: cols}
}

func (s *SchemaMigrationsDef) To(v *SchemaMigrations) cqlc.TableBinding {
	cols := []cqlc.ColumnBinding{

		cqlc.ColumnBinding{Column: &SchemaMigrationsVersionColumn{}, Value: &v.Version},
	}
	return cqlc.TableBinding{Table: &SchemaMigrationsDef{}, Columns: cols}
}

func (s *SchemaMigrationsDef) ColumnDefinitions() []cqlc.Column {
	return []cqlc.Column{

		&SchemaMigrationsVersionColumn{},
	}
}

func SchemaMigrationsTableDef() *SchemaMigrationsDef {
	return &SchemaMigrationsDef{

		VERSION: &SchemaMigrationsVersionColumn{},
	}
}

func (s *SchemaMigrationsDef) VersionColumn() cqlc.LastPartitionedInt64Column {
	return &SchemaMigrationsVersionColumn{}
}
